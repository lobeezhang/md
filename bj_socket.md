Linux 下使用 <sys/socket.h> 头文件中 socket() 函数来创建套接字：

```c
int socket(int af, int type, int protocol);
```

1. af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。

AF_INET 表示 IPv4 地址，例如 127.0.0.1；

AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。

`127.0.0.1`它是一个特殊IP地址，表示本机地址

2. type 为数据传输方式/套接字类型
3. protocol 表示传输协议，常用的有 `IPPROTO_TCP `和` IPPROTO_UDP`



有了地址类型和数据传输方式，还不足以决定采用哪种协议吗？为什么还需要第三个参数呢？

正如大家所想，一般情况下有了 af 和 type 两个参数就可以创建套接字了，操作系统会自动推演出协议类型，除非遇到这样的情况：有两种不同的协议支持同一种地址类型和数据传输类型。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。

本教程使用 IPv4 地址，参数 af 的值为 PF_INET。如果使用 SOCK_STREAM 传输数据，那么满足这两个条件的协议只有 TCP。



##### 客户端（tcp层-connect-概述）：

- 客户端自动绑定端口号是在connect函数中实现的，sk已经具备本地地址信息，这里在赋值目的地址信息，这样sock套接字就具备了本地与对端两者的地址信息 （包含大小端转换等）
- 初始化一个序列号，跟当前时间挂钩的序列号；窗口大小，用write_seq初始化；
- 以上准备好后，会开辟一个网络数据包结构，初始化并存入全部信息，最后查找合适的路由表项 
- 检查mtu大小，tcp校验
- 最后connect会激发三次握手，并设置定时器，

##### 服务端（tcp层概述）：

调用listen方法后，服务端就打开了三次握手的开关，能够处理来自客户端的SYN分节了，

同时内核为任何一个给定的监听套接字维护两个队列：未完成连接队列和已完成连接队列，当客户SYN到达时，如果队列是满的，TCP就忽略该分节，但不会发送RST；当进程调用accept时，已完成队列的对头项将返回给进程，如果队列是空，则阻塞（套接字默认阻塞）；

只要我调用了listen方法后，只要三次握手完成，客户端就会connect成功，而跟服务端调用accept没任何关系，accept只是去取已完成连接队列的对头项。



客户端是主动打开连接的一端，会发送第一个SYN分节，然后等待确认，此时连接状态为SYN_SENT，当收到服务端的确认后连接建立，状态变为ESTABLISHED；

服务器是被动打开连接的一端，调用listen导致套接字从CLOSED状态变为LISTEN状态，当收到来自客户端的SYN分节以后状态变为SYN_RCVD，然后发送第二个SYN分节，等待客户端的确认，收到客户端的确认以后连接建立，状态变为ESTABLISHED；